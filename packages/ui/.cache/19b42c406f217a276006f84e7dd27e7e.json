{"dependencies":[{"name":"./shared.js","loc":{"line":8,"column":7}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Store = undefined;\n\nvar _shared = require(\"./shared.js\");\n\nfunction Store(state) {\n  this._observers = { pre: (0, _shared.blankObject)(), post: (0, _shared.blankObject)() };\n  this._changeHandlers = [];\n  this._dependents = [];\n\n  this._computed = (0, _shared.blankObject)();\n  this._sortedComputedProperties = [];\n\n  this._state = (0, _shared.assign)({}, state);\n}\n\n(0, _shared.assign)(Store.prototype, {\n  _add: function (component, props) {\n    this._dependents.push({\n      component: component,\n      props: props\n    });\n  },\n\n  _init: function (props) {\n    var state = {};\n    for (var i = 0; i < props.length; i += 1) {\n      var prop = props[i];\n      state['$' + prop] = this._state[prop];\n    }\n    return state;\n  },\n\n  _remove: function (component) {\n    var i = this._dependents.length;\n    while (i--) {\n      if (this._dependents[i].component === component) {\n        this._dependents.splice(i, 1);\n        return;\n      }\n    }\n  },\n\n  _sortComputedProperties: function () {\n    var computed = this._computed;\n    var sorted = this._sortedComputedProperties = [];\n    var cycles;\n    var visited = (0, _shared.blankObject)();\n\n    function visit(key) {\n      if (cycles[key]) {\n        throw new Error('Cyclical dependency detected');\n      }\n\n      if (visited[key]) return;\n      visited[key] = true;\n\n      var c = computed[key];\n\n      if (c) {\n        cycles[key] = true;\n        c.deps.forEach(visit);\n        sorted.push(c);\n      }\n    }\n\n    for (var key in this._computed) {\n      cycles = (0, _shared.blankObject)();\n      visit(key);\n    }\n  },\n\n  compute: function (key, deps, fn) {\n    var store = this;\n    var value;\n\n    var c = {\n      deps: deps,\n      update: function (state, changed, dirty) {\n        var values = deps.map(function (dep) {\n          if (dep in changed) dirty = true;\n          return state[dep];\n        });\n\n        if (dirty) {\n          var newValue = fn.apply(null, values);\n          if ((0, _shared.differs)(newValue, value)) {\n            value = newValue;\n            changed[key] = true;\n            state[key] = value;\n          }\n        }\n      }\n    };\n\n    c.update(this._state, {}, true);\n\n    this._computed[key] = c;\n    this._sortComputedProperties();\n  },\n\n  get: _shared.get,\n\n  observe: _shared.observe,\n\n  onchange: function (callback) {\n    this._changeHandlers.push(callback);\n    return {\n      cancel: function () {\n        var index = this._changeHandlers.indexOf(callback);\n        if (~index) this._changeHandlers.splice(index, 1);\n      }\n    };\n  },\n\n  set: function (newState) {\n    var oldState = this._state,\n        changed = this._changed = {},\n        dirty = false;\n\n    for (var key in newState) {\n      if (this._computed[key]) throw new Error(\"'\" + key + \"' is a read-only property\");\n      if ((0, _shared.differs)(newState[key], oldState[key])) changed[key] = dirty = true;\n    }\n    if (!dirty) return;\n\n    this._state = (0, _shared.assign)({}, oldState, newState);\n\n    for (var i = 0; i < this._sortedComputedProperties.length; i += 1) {\n      this._sortedComputedProperties[i].update(this._state, changed);\n    }\n\n    for (var i = 0; i < this._changeHandlers.length; i += 1) {\n      this._changeHandlers[i](this._state, changed);\n    }\n\n    (0, _shared.dispatchObservers)(this, this._observers.pre, changed, this._state, oldState);\n\n    var dependents = this._dependents.slice(); // guard against mutations\n    for (var i = 0; i < dependents.length; i += 1) {\n      var dependent = dependents[i];\n      var componentState = {};\n      dirty = false;\n\n      for (var j = 0; j < dependent.props.length; j += 1) {\n        var prop = dependent.props[j];\n        if (prop in changed) {\n          componentState['$' + prop] = this._state[prop];\n          dirty = true;\n        }\n      }\n\n      if (dirty) dependent.component.set(componentState);\n    }\n\n    (0, _shared.dispatchObservers)(this, this._observers.post, changed, this._state, oldState);\n  }\n});\n\nexports.Store = Store;"},"hash":"49e21649f1f71001fd0a7a644f9d75b9"}